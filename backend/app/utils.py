import logging
import json
from datetime import datetime
from typing import Any, Dict, Optional
from .schemas import DecisionInput, DecisionOutput

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def log_decision_request(decision_input: DecisionInput, request_id: str) -> None:
    """
    Log the incoming decision request with details
    
    Args:
        decision_input: The decision input being processed
        request_id: Unique request identifier for tracing
    """
    log_data = {
        "request_id": request_id,
        "timestamp": datetime.utcnow().isoformat(),
        "decision_type": decision_input.decision_type,
        "context_length": len(decision_input.context),
        "constraint_count": len(decision_input.constraints),
        "has_preferences": bool(decision_input.preferences)
    }
    logger.info(f"Decision Request: {json.dumps(log_data)}")


def log_decision_output(decision_output: DecisionOutput, request_id: str, processing_time_ms: float) -> None:
    """
    Log the decision output with metrics
    
    Args:
        decision_output: The decision output generated by the agent
        request_id: Unique request identifier for tracing
        processing_time_ms: Time taken to process in milliseconds
    """
    log_data = {
        "request_id": request_id,
        "timestamp": datetime.utcnow().isoformat(),
        "recommendation_length": len(decision_output.recommendation),
        "reasoning_count": len(decision_output.reasoning),
        "confidence_score": decision_output.confidence_score,
        "has_alternative": decision_output.alternative_option is not None,
        "processing_time_ms": processing_time_ms
    }
    logger.info(f"Decision Output: {json.dumps(log_data)}")


def log_decision_error(decision_input: DecisionInput, error: Exception, request_id: str, fallback_used: bool = False) -> None:
    """
    Log errors during decision processing
    
    Args:
        decision_input: The decision input that caused the error
        error: The exception that occurred
        request_id: Unique request identifier for tracing
        fallback_used: Whether fallback was activated
    """
    log_data = {
        "request_id": request_id,
        "timestamp": datetime.utcnow().isoformat(),
        "decision_type": decision_input.decision_type,
        "error_type": type(error).__name__,
        "error_message": str(error),
        "fallback_used": fallback_used
    }
    logger.error(f"Decision Processing Error: {json.dumps(log_data)}")


def log_fallback_activation(reason: str, request_id: str, original_error: Optional[Exception] = None) -> None:
    """
    Log when fallback mechanism is activated
    
    Args:
        reason: Reason for fallback activation
        request_id: Unique request identifier for tracing
        original_error: The original error that triggered fallback
    """
    log_data = {
        "request_id": request_id,
        "timestamp": datetime.utcnow().isoformat(),
        "reason": reason,
        "original_error": str(original_error) if original_error else None
    }
    logger.warning(f"Fallback Activated: {json.dumps(log_data)}")


def create_safe_fallback_response(
    decision_type: str,
    context: str,
    constraint_count: int = 0,
    reason: str = "Model unavailable"
) -> DecisionOutput:
    """
    Create a safe, conservative fallback response when AI fails
    
    Args:
        decision_type: Type of decision being made
        context: The context of the decision
        constraint_count: Number of constraints provided
        reason: Reason for fallback activation
        
    Returns:
        DecisionOutput: A safe default decision output
    """
    reasoning = [
        f"Fallback activated: {reason}",
        f"Decision type: {decision_type}",
        f"Context available: {len(context) > 0}",
        f"Constraints considered: {constraint_count}"
    ]
    
    return DecisionOutput(
        recommendation="Unable to generate AI recommendation at this time. Please review the decision context and constraints manually.",
        reasoning=reasoning,
        confidence_score=0.2,
        alternative_option="Escalate to human decision-maker for immediate review"
    )


def create_timeout_fallback_response() -> DecisionOutput:
    """
    Create a fallback response specifically for timeout scenarios
    
    Returns:
        DecisionOutput: A timeout-specific fallback decision
    """
    return DecisionOutput(
        recommendation="Decision processing timed out. Recommend immediate escalation.",
        reasoning=[
            "AI model request exceeded timeout threshold",
            "System unable to generate timely recommendation",
            "Human intervention required"
        ],
        confidence_score=0.1,
        alternative_option="Use historical precedent or expert judgment for decision"
    )


def create_validation_error_fallback(error_details: str) -> DecisionOutput:
    """
    Create a fallback response for validation errors
    
    Args:
        error_details: Details about the validation error
        
    Returns:
        DecisionOutput: A validation-error-specific fallback decision
    """
    return DecisionOutput(
        recommendation="Input validation failed. Unable to process decision request.",
        reasoning=[
            f"Validation error: {error_details}",
            "Please verify input parameters and constraints",
            "Ensure all required fields are properly formatted"
        ],
        confidence_score=0.0,
        alternative_option="Resubmit request with corrected input parameters"
    )


def sanitize_decision_log(decision_output: DecisionOutput, max_length: int = 500) -> Dict[str, Any]:
    """
    Create a sanitized version of decision output for logging/storage
    
    Args:
        decision_output: The decision output to sanitize
        max_length: Maximum length for recommendation text
        
    Returns:
        Dictionary with sanitized decision data
    """
    return {
        "recommendation": decision_output.recommendation[:max_length],
        "reasoning_count": len(decision_output.reasoning),
        "confidence_score": decision_output.confidence_score,
        "has_alternative": decision_output.alternative_option is not None
    }
